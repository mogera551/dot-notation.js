const e="*",t="dot-notation",s={directlyGet:Symbol.for(t+".direct_get"),directlySet:Symbol.for(t+".direct_set"),isSupportDotNotation:Symbol.for(t+".is_support_dot_notation")},a=new RegExp(/^\$([0-9]+)$/);class r{name;pathNames=[];parentPathNames=[];parentPath;parentPaths=[];setOfParentPaths;regexp;level=0;isPrimitive;constructor(t){if(this.name=t,this.pathNames=t.split("."),this.parentPathNames=this.pathNames.slice(0,-1),this.parentPaths=this.parentPathNames.reduce(((e,t)=>(e.push(e.at(-1)?.concat(t)??[t]),e)),[]).map((e=>e.join("."))),this.setOfParentPaths=new Set(this.parentPaths),this.parentPath=this.parentPathNames.join("."),this.lastPathName=this.pathNames.at(-1),this.regexp=new RegExp("^"+t.replaceAll(".","\\.").replaceAll("*","([0-9a-zA-Z_]*)")+"$"),this.level=this.pathNames.filter((t=>t===e)).length,this.isPrimitive=1===this.pathNames.length,this.nearestWildcardName=void 0,this.nearestWildcardParentName=void 0,this.level>0)for(let t=this.pathNames.length-1;t>=0;t--)if(this.pathNames[t]===e){this.nearestWildcardName=this.pathNames.slice(0,t+1).join("."),this.nearestWildcardParentName=this.pathNames.slice(0,t).join(".");break}}findNearestWildcard(){return r.findNearestWildcard(this)}static findNearestWildcard(t){let s=t;for(;;){if(s.lastPathName===e)return s;if(""===s.parentPath)return;s=r.create(s.parentPath)}}static create(e){const t=this.propertyNameByName.get(e);if(t)return t;const s=new r(e);return this.propertyNameByName.set(e,s),s}static propertyNameByName=new Map;static parse(e){const t=[],s=[];for(const a of e.split(".")){const e=Number(a);isNaN(e)?s.push(a):(t.push(e),s.push("*"))}return{propName:r.create(s.join(".")),indexes:t}}}class i{#e=[];#t=new Map;get lastIndexes(){return this.#e[this.#e.length-1]}get stackIndexes(){return this.#e}get matchByName(){return this.#t}getByPropertyName(t,{propName:s},a){let i;if(Reflect.has(t,s.name))i=Reflect.get(t,s.name,a);else if(""!==s.parentPath){const n=r.create(s.parentPath),h=this.getByPropertyName(t,{propName:n},a);if(void 0!==h){const t=s.lastPathName===e?this.lastIndexes[s.level-1]:s.lastPathName;i=Reflect.get(h,t)}}return i}setByPropertyName(t,{propName:s,value:a},i){let n=!1;if(Reflect.has(t,s.name)||s.isPrimitive)n=Reflect.set(t,s.name,a,i);else{const h=r.create(s.parentPath),p=this.getByPropertyName(t,{propName:h},i);if(void 0!==p){const t=s.lastPathName===e?this.lastIndexes[s.level-1]:s.lastPathName;n=Reflect.set(p,t,a)}}return n}pushIndexes(e,t){this.#e.push(e);try{return Reflect.apply(t,this,[])}finally{this.#e.pop()}}getFunc=(e,t)=>({propName:s,indexes:a})=>this.pushIndexes(a,(()=>this.getByPropertyName(e,{propName:s},t)));setFunc=(e,t)=>({propName:s,indexes:a},r)=>this.pushIndexes(a,(()=>this.setByPropertyName(e,{propName:s,value:r},t)));getExpandLastLevel(e,{propName:t,indexes:s},a){const i=this.getFunc(e,a),n=t.findNearestWildcard();if(!n)throw new Error(`not found wildcard path of '${t.name}'`);const h=r.create(n.parentPath);return i({propName:h,indexes:s}).map(((e,a)=>i({propName:t,indexes:s.concat(a)})))}setExpandLastLevel(e,{propName:t,indexes:s,values:a},i){const n=this.getFunc(e,i),h=this.setFunc(e,i),p=t.findNearestWildcard();if(!p)throw new Error(`not found wildcard path of '${t.name}'`);const l=r.create(p.parentPath),o=n({propName:l,indexes:s});if(p.name===t.name)h({propName:l,indexes:s},a);else{if(a.length!==o.length)throw new Error(`not match value count '${t.name}'`);for(let e in o)h({propName:t,indexes:s.concat(Number(e))},a[e])}return!0}[s.directlyGet](e,{prop:t,indexes:s},a){const i=r.create(t);return this.pushIndexes(s,(()=>this.getByPropertyName(e,{propName:i},a)))}[s.directlySet](e,{prop:t,indexes:s,value:a},i){const n=r.create(t);return this.pushIndexes(s,(()=>this.setByPropertyName(e,{propName:n,value:a},i)))}get(e,t,i){if("string"==typeof t&&(t.startsWith("@@__")||"constructor"===t))return Reflect.get(e,t,i);const n=this.getFunc(e,i),h=this.lastIndexes;let p;if(t===s.directlyGet)return(t,a)=>Reflect.apply(this[s.directlyGet],this,[e,{prop:t,indexes:a},i]);if(t===s.directlySet)return(t,a,r)=>Reflect.apply(this[s.directlySet],this,[e,{prop:t,indexes:a,value:r},i]);if(t===s.isSupportDotNotation)return!0;if(p=a.exec(t))return h?.[Number(p[1])-1]??void 0;if("@"===t.at(0)){const s=t.slice(1),a=r.create(s);if((h?.length??0)+1<a.level)throw new Error("array level not match");const n=h?.slice(0,a.level-1)??[];return this.getExpandLastLevel(e,{propName:a,indexes:n},i)}if(this.#t.has(t))return n(this.#t.get(t));const l=r.parse(t);return l.propName.level===l.indexes.length&&this.#t.set(t,l),l.indexes.push(...h?.slice(l.indexes.length)??[]),n(l)}set(e,t,s,a){if("string"==typeof t&&(t.startsWith("@@__")||"constructor"===t))return Reflect.set(e,t,s,a);const i=this.setFunc(e,a),n=this.lastIndexes;if("@"===t.at(0)){const i=t.slice(1),n=r.create(i);if((this.lastIndexes?.length??0)+1<n.level)throw new Error("array level not match");const h=this.lastIndexes?.slice(0,n.level-1)??[];return this.setExpandLastLevel(e,{propName:n,indexes:h,values:s},a)}if(this.#t.has(t))return i(this.#t.get(t),s);const h=r.parse(t);return h.propName.level===h.indexes.length&&this.#t.set(t,h),this.#t.set(t,h),h.indexes.push(...n?.slice(h.indexes.length)??[]),i(h,s)}}export{i as Handler,r as PropertyName,a as RE_CONTEXT_INDEX,s as Symbols};
