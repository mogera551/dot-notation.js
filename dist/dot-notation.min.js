const e="*",t="dot-notation",r={directlyGet:Symbol.for(t+".direct_get"),directlySet:Symbol.for(t+".direct_set"),isSupportDotNotation:Symbol.for(t+".is_support_dot_notation")},s=new RegExp(/^\$([0-9]+)$/);class a{name;pathNames=[];parentPathNames=[];parentPath;parentPaths=[];setOfParentPaths;regexp;level=0;isPrimitive;constructor(t){this.name=t,this.pathNames=t.split("."),this.parentPathNames=this.pathNames.slice(0,-1),this.parentPaths=this.parentPathNames.reduce(((e,t)=>(e.push(e.at(-1)?.concat(t)??[t]),e)),[]).map((e=>e.join("."))),this.setOfParentPaths=new Set(this.parentPaths),this.parentPath=this.parentPathNames.join("."),this.lastPathName=this.pathNames.at(-1),this.regexp=new RegExp("^"+t.replaceAll(".","\\.").replaceAll("*","([0-9a-zA-Z_]*)")+"$"),this.level=this.pathNames.filter((t=>t===e)).length,this.isPrimitive=1===this.pathNames.length}findNearestWildcard(){return a.findNearestWildcard(this)}static findNearestWildcard(t){return t.lastPathName===e?t:""!==t.parentPath?this.findNearestWildcard(a.create(t.parentPath)):void 0}static create(e){const t=this.propertyNameByName.get(e);if(t)return t;const r=new a(e);return this.propertyNameByName.set(e,r),r}static propertyNameByName=new Map}class n{#e=[];#t;#r;#s;constructor(e){if(null==e)throw new Error("definedProperties is null");this.#t=new Set(e),this.#r=e.map((e=>a.create(e))),this.#s=new Map}get lastIndexes(){return this.#e[this.#e.length-1]}get stackIndexes(){return this.#e}get setOfDefinedProperties(){return this.#t}get definedPropertyNames(){return this.#r}get matchByName(){return this.#s}getByPropertyName(t,{propName:r},s){if(Reflect.has(t,r.name))return Reflect.get(t,r.name,s);{if(""===r.parentPath)return;const n=a.create(r.parentPath),i=this.getByPropertyName(t,{propName:n},s),o=r.lastPathName===e?this.lastIndexes[r.level-1]:r.lastPathName;return Reflect.get(i,o)}}setByPropertyName(t,{propName:r,value:s},n){if(Reflect.has(t,r.name))Reflect.set(t,r.name,s,n);else{const i=a.create(r.parentPath),o=this.getByPropertyName(t,{propName:i},n),p=r.lastPathName===e?this.lastIndexes[r.level-1]:r.lastPathName;Reflect.set(o,p,s)}return!0}pushIndexes(e,t){this.#e.push(e);try{return Reflect.apply(t,this,[])}finally{this.#e.pop()}}getFunc=(e,t)=>({propName:r,indexes:s})=>this.pushIndexes(s,(()=>this.getByPropertyName(e,{propName:r},t)));setFunc=(e,t)=>({propName:r,indexes:s},a)=>this.pushIndexes(s,(()=>this.setByPropertyName(e,{propName:r,value:a},t)));getExpandLastLevel(e,{propName:t,indexes:r},s){const n=this.getFunc(e,s),i=t.findNearestWildcard();if(!i)throw new Error(`not found wildcard path of '${t.name}'`);const o=a.create(i.parentPath);return n({propName:o,indexes:r}).map(((e,s)=>n({propName:t,indexes:r.concat(s)})))}setExpandLastLevel(e,{propName:t,indexes:r,values:s},n){const i=this.getFunc(e,n),o=this.setFunc(e,n),p=t.findNearestWildcard();if(!p)throw new Error(`not found wildcard path of '${t.name}'`);const h=a.create(p.parentPath),c=i({propName:h,indexes:r});if(p.name===t.name)o({propName:h,indexes:r},s);else{if(s.length!==c.length)throw new Error(`not match value count '${t.name}'`);for(let e in c)o({propName:t,indexes:r.concat(Number(e))},s[e])}return!0}get(e,t,n){const i=this.getFunc(e,n);let o;if(t===r.directlyGet)return(t,r)=>{if(this.#t.has(t))return this.pushIndexes(r,(()=>this.getByPropertyName(e,{propName:a.create(t)},n)));throw new Error(`undefined property ${t}`)};if(t===r.directlySet)return(t,r,s)=>{if(this.#t.has(t))return this.pushIndexes(r,(()=>this.setByPropertyName(e,{propName:a.create(t),value:s},n)));throw new Error(`undefined property ${t}`)};if(t===r.isSupportDotNotation)return!0;if(o=s.exec(t))return this.lastIndexes?.[Number(o[1])-1]??void 0;if("@"===t.at(0)){const r=t.slice(1);if(!this.#t.has(r))throw new Error(`undefined property ${r}`);const s=a.create(r);if((this.lastIndexes?.length??0)+1<s.level)throw new Error("array level not match");const i=this.lastIndexes?.slice(0,s.level-1)??[];return this.getExpandLastLevel(e,{propName:s,indexes:i},n)}if(this.#t.has(t))return this.getByPropertyName(e,{propName:a.create(t)},n);if(this.#s.has(t))return i(this.#s.get(t));for(const e of this.#r){const r=e.regexp.exec(t);if(!r)continue;const s=r.slice(1);return this.#s.set(t,{propName:e,indexes:s}),i({propName:e,indexes:s})}throw new Error(`undefined property ${t}`)}set(e,t,r,s){const n=this.setFunc(e,s);if("@"===t.at(0)){const n=t.slice(1);if(!this.#t.has(n))throw new Error(`undefined property ${n}`);const i=a.create(n);if((this.lastIndexes?.length??0)+1<i.level)throw new Error("array level not match");const o=this.lastIndexes?.slice(0,i.level-1)??[];return this.setExpandLastLevel(e,{propName:i,indexes:o,values:r},s)}if(this.#t.has(t))return this.setByPropertyName(e,{propName:a.create(t),value:r},s);if(this.#s.has(t))return n(this.#s.get(t),r);for(const e of this.#r){const s=e.regexp.exec(t);if(!s)continue;const a=s.slice(1);return this.#s.set(t,{propName:e,indexes:a}),n({propName:e,indexes:a},r)}throw new Error(`undefined property ${t}`)}}export{n as Handler,a as PropertyName,s as RE_CONTEXT_INDEX,r as Symbols};
