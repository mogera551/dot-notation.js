const e="*",t="dot-notation",r=Symbol.for(t+".direct_get"),s=Symbol.for(t+".direct_set");class a{name;pathNames=[];parentPathNames=[];parentPath;regexp;level=0;constructor(t){this.name=t,this.pathNames=t.split("."),this.parentPathNames=this.pathNames.slice(0,-1),this.parentPath=this.parentPathNames.join("."),this.lastPathName=this.pathNames.at(-1),this.regexp=new RegExp("^"+t.replaceAll(".","\\.").replaceAll("*","([0-9a-zA-Z_]*)")+"$"),this.level=this.pathNames.filter((t=>t===e)).length}static create(e){const t=this.propertyNameByName.get(e);if(t)return t;const r=new a(e);return this.propertyNameByName.set(e,r),r}static propertyNameByName=new Map}class n{#e=[];#t;#r;#s;constructor(e){if(null==e)throw new Error("definedProperties is null");this.#t=new Set(e),this.#r=e.map((e=>a.create(e))),this.#s=new Map}get lastIndexes(){return this.#e[this.#e.length-1]}get stackIndexes(){return this.#e}get setOfDefinedProperties(){return this.#t}get definedPropertyNames(){return this.#r}get matchByName(){return this.#s}#a(t,r,s){let n;if(Reflect.has(t,r.name,s))n=Reflect.get(t,r.name,s);else{const i=this.#a(t,a.create(r.parentPath),s),h=r.lastPathName===e?this.lastIndexes[r.level-1]:r.lastPathName;n=Reflect.get(i,h)}return n}#n(t,r,s,n){if(Reflect.has(t,r.name,n))Reflect.set(t,r.name,s,n);else{const i=this.#a(t,a.create(r.parentPath),n),h=r.lastPathName===e?this.lastIndexes[r.level-1]:r.lastPathName;Reflect.set(i,h,s)}return!0}#i(e,t){this.#e.push(e);try{return Reflect.apply(t,this,[])}finally{this.#e.pop()}}get(t,n,i){const h=({propName:e,indexes:r})=>this.#i(r,(()=>this.#a(t,e,i)));let o;if(n===r)return(e,r)=>{if(this.#t.has(e))return this.#i(r,(()=>this.#a(t,a.create(e),i)));throw new Error(`undefined property ${e}`)};if(n===s)return(e,r,s)=>{if(this.#t.has(e))return this.#i(r,(()=>this.#n(t,a.create(e),s,i)));throw new Error(`undefined property ${e}`)};if(o=/^\$([0-9]+)$/.exec(n))return this.lastIndexes?.[Number(o[1])-1]??void 0;if("@"===n.at(0)){const t=n.slice(1);if(!this.#t.has(t))throw new Error(`undefined property ${t}`);const r=a.create(t);if((this.lastIndexes?.length??0)+1<r.level)throw new Error("array level not match");const s=this.lastIndexes?.slice(0,r.level-1)??[],i=t=>t.lastPathName===e?t:""!==t.parentPath?i(a.create(t.parentPath)):void 0,o=i(r);if(!o)throw new Error(`not found wildcard path of '${t}'`);const p=a.create(o.parentPath),c=[];for(let e in h({propName:p,indexes:s})){const t=s.concat(Number(e));c.push(h({propName:r,indexes:t}))}return c}if(this.#t.has(n))return this.#a(t,a.create(n),i);if(this.#s.has(n))return h(this.#s.get(n));for(const e of this.#r){const t=e.regexp.exec(n);if(!t)continue;const r=t.slice(1);return this.#s.set(n,{propName:e,indexes:r}),h({propName:e,indexes:r})}throw new Error(`undefined property ${n}`)}set(e,t,r,s){if(this.#t.has(t))return this.#n(e,a.create(t),r,s);const n=({propName:t,indexes:r},a)=>this.#i(r,(()=>this.#n(e,t,a,s)));if(this.#s.has(t))return n(this.#s.get(t),r);for(const e of this.#r){const s=e.regexp.exec(t);if(!s)continue;const a=s.slice(1);return this.#s.set(t,{propName:e,indexes:a}),n({propName:e,indexes:a},r)}throw new Error(`undefined property ${t}`)}}export{n as Handler,r as SYM_DIRECT_GET,s as SYM_DIRECT_SET};
