const e="dot-notation",t=Symbol.for(e+".direct_get"),r=Symbol.for(e+".direct_set");class s{name;pathNames=[];parentPathNames=[];parentPath;regexp;level=0;constructor(e){this.name=e,this.pathNames=e.split("."),this.parentPathNames=this.pathNames.slice(0,-1),this.parentPath=this.parentPathNames.join("."),this.lastPathName=this.pathNames.at(-1),this.regexp=new RegExp("^"+e.replaceAll(".","\\.").replaceAll("*","([0-9a-zA-Z_]*)")+"$"),this.level=this.pathNames.filter((e=>"*"===e)).length}static create(e){const t=this.propertyNameByName.get(e);if(t)return t;const r=new s(e);return this.propertyNameByName.set(e,r),r}static propertyNameByName=new Map}class a{#e=[];#t;#r;#s;constructor(e){if(null==e)throw new Error("definedProperties is null");this.#t=new Set(e),this.#r=e.map((e=>s.create(e))),this.#s=new Map}get lastIndexes(){return this.#e[this.#e.length-1]}get stackIndexes(){return this.#e}get setOfDefinedProperties(){return this.#t}get definedPropertyNames(){return this.#r}get matchByName(){return this.#s}#a(e,t,r){let a;if(Reflect.has(e,t.name,r))a=Reflect.get(e,t.name,r);else{const i=this.#a(e,s.create(t.parentPath),r),n="*"===t.lastPathName?this.lastIndexes[t.level-1]:t.lastPathName;a=Reflect.get(i,n)}return a}#i(e,t,r,a){if(Reflect.has(e,t.name,a))Reflect.set(e,t.name,r,a);else{const i=this.#a(e,s.create(t.parentPath),a),n="*"===t.lastPathName?this.lastIndexes[t.level-1]:t.lastPathName;Reflect.set(i,n,r)}return!0}get(e,a,i){let n;if(a===t)return(t,r)=>{if(this.#t.has(t)){this.#e.push(r);try{return this.#a(e,s.create(t),i)}finally{this.#e.pop()}}throw new Error(`undefined property ${t}`)};if(a===r)return(t,r,a)=>{if(this.#t.has(t)){this.#e.push(r);try{return this.#i(e,s.create(t),a,i)}finally{this.#e.pop()}}throw new Error(`undefined property ${t}`)};if(n=/^\$([0-9]+)$/.exec(a))return this.lastIndexes?.[Number(n[1])-1]??void 0;if(this.#t.has(a))return this.#a(e,s.create(a),i);const h=({propName:t,match:r})=>{this.#e.push(r.slice(1));try{return this.#a(e,t,i)}finally{this.#e.pop()}};if(this.#s.has(a))return h(this.#s.get(a));for(const e of this.#r){const t=e.regexp.exec(a);if(t)return this.#s.set(a,{propName:e,match:t}),h({propName:e,match:t})}throw new Error(`undefined property ${a}`)}set(e,t,r,a){if(this.#t.has(t))return this.#i(e,s.create(t),r,a);const i=({propName:t,match:r},s)=>{this.#e.push(r.slice(1));try{return this.#i(e,t,s,a)}finally{this.#e.pop()}};if(this.#s.has(t))return i(this.#s.get(t),r);for(const e of this.#r){const s=e.regexp.exec(t);if(s)return this.#s.set(t,{propName:e,match:s}),i({propName:e,match:s},r)}throw new Error(`undefined property ${t}`)}}export{a as Handler,t as SYM_DIRECT_GET,r as SYM_DIRECT_SET};
