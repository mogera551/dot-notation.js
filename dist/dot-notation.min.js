const e="*",t="dot-notation",a={directlyGet:Symbol.for(t+".direct_get"),directlySet:Symbol.for(t+".direct_set"),isSupportDotNotation:Symbol.for(t+".is_support_dot_notation")},r=new RegExp(/^\$([0-9]+)$/);class s{#e;get name(){return this.#e}#t;get pathNames(){return this.#t}#a;get parentPathNames(){return this.#a}#r;get parentPath(){return this.#r}#s;get parentPaths(){return this.#s}#n;get setOfParentPaths(){return this.#n}#i;get lastPathName(){return this.#i}#h;get regexp(){return this.#h}#p;get level(){return this.#p}#o;get isPrimitive(){return this.#o}#c;get nearestWildcardName(){return this.#c}#l;get nearestWildcardParentName(){return this.#l}constructor(t){if(this.#e=t,this.#t=t.split("."),this.#a=this.#t.slice(0,-1),this.#s=this.#a.reduce(((e,t)=>(e.push(e.at(-1)?.concat(t)??[t]),e)),[]).map((e=>e.join("."))),this.#n=new Set(this.#s),this.#r=this.#a.join("."),this.#i=this.#t.at(-1),this.#h=new RegExp("^"+t.replaceAll(".","\\.").replaceAll("*","([0-9a-zA-Z_]*)")+"$"),this.#p=this.#t.reduce(((t,a)=>t+(a===e?1:0)),0),this.#o=1===this.#t.length,this.#c=void 0,this.#l=void 0,this.#p>0)for(let t=this.#t.length-1;t>=0;t--)if(this.#t[t]===e){this.#c=this.#t.slice(0,t+1).join("."),this.#l=this.#t.slice(0,t).join(".");break}}static create(e){const t=this.#m.get(e);if(void 0!==t)return t;const a=new s(e);return this.#m.set(e,a),a}static#m=new Map;static get propertyNameByName(){return this.#m}static parse(e){const t=[],a=[];for(const r of e.split(".")){const e=Number(r);isNaN(e)?a.push(r):(t.push(e),a.push("*"))}return{propName:s.create(a.join(".")),indexes:t}}}const n={[a.directlyGet]:(e,t,a)=>(r,s)=>Reflect.apply(e.directlyGet,e,[t,{prop:r,indexes:s},a]),[a.directlySet]:(e,t,a)=>(r,s,n)=>Reflect.apply(e.directlySet,e,[t,{prop:r,indexes:s,value:n},a]),[a.isSupportDotNotation]:(e,t,a)=>!0};class i{#d=[];#N=new Map;get lastIndexes(){return this.#d[this.#d.length-1]}get stackIndexes(){return this.#d}get matchByName(){return this.#N}getByPropertyName(t,{propName:a},r){const n=Reflect.get(t,a.name,r);if(void 0!==n)return n;if(""===a.parentPath)return;const i=this.getByPropertyName(t,{propName:s.create(a.parentPath)},r);if(void 0===i)return;return i[a.lastPathName===e?this.lastIndexes[a.level-1]:a.lastPathName]}setByPropertyName(t,{propName:a,value:r},n){if(Reflect.has(t,a.name)||a.isPrimitive)return Reflect.set(t,a.name,r,n);{const i=this.getByPropertyName(t,{propName:s.create(a.parentPath)},n);if(void 0===i)return!1;return i[a.lastPathName===e?this.lastIndexes[a.level-1]:a.lastPathName]=r,!0}}#u(e,t){this.#d.push(e);try{return Reflect.apply(t,this,[])}finally{this.#d.pop()}}#y=(e,t)=>({propName:a,indexes:r})=>this.#u(r,(()=>this.getByPropertyName(e,{propName:a},t)));#g=(e,t)=>({propName:a,indexes:r},s)=>this.#u(r,(()=>this.setByPropertyName(e,{propName:a,value:s},t)));#x(e,{propName:t,indexes:a},r){const n=this.#y(e,r);if(void 0===t.nearestWildcardName)throw new Error(`not found wildcard path of '${t.name}'`);const i=s.create(t.nearestWildcardParentName);return n({propName:i,indexes:a}).map(((e,r)=>n({propName:t,indexes:a.concat(r)})))}#P(e,{propName:t,indexes:a,values:r},n){const i=this.#y(e,n),h=this.#g(e,n);if(void 0===t.nearestWildcardName)throw new Error(`not found wildcard path of '${t.name}'`);const p=s.create(t.nearestWildcardParentName),o=i({propName:p,indexes:a}),c=Array.isArray(r)?r:[...Array(o.length)].map((e=>r));if(t.nearestWildcardName===t.name)h({propName:p,indexes:a},c);else{if(c.length!==o.length)throw new Error(`not match array count '${t.name}'`);for(let e in o)h({propName:t,indexes:a.concat(Number(e))},c[e])}return!0}directlyGet(e,{prop:t,indexes:a},r){const n=s.create(t);return this.#u(a,(()=>this.getByPropertyName(e,{propName:n},r)))}directlySet(e,{prop:t,indexes:a,value:r},n){const i=s.create(t);return this.#u(a,(()=>this.setByPropertyName(e,{propName:i,value:r},n)))}get(e,t,a){const i="string"==typeof t;if(i&&(t.startsWith("@@__")||"constructor"===t))return Reflect.get(e,t,a);const h=n[t];if(void 0!==h)return h(this,e,a);const p=this.#y(e,a),o=this.lastIndexes;let c;if(i){if("$"===t[0]&&(c=r.exec(t)))return o?.[Number(c[1])-1]??void 0;if("@"===t[0]){const r=t.slice(1),n=s.create(r);if((o?.length??0)+1<n.level)throw new Error("array level not match");const i=o?.slice(0,n.level-1)??[];return this.#x(e,{propName:n,indexes:i},a)}if(void 0!==this.#N.get(t))return p(this.#N.get(t));{const e=s.parse(t);return e.propName.level===e.indexes.length?(this.#N.set(t,e),p(e)):p({propName:e.propName,indexes:e.indexes.concat(o?.slice(e.indexes.length)??[])})}}return Reflect.get(e,t,a)}set(e,t,a,r){if("string"==typeof t){if(t.startsWith("@@__")||"constructor"===t)return Reflect.set(e,t,a,r);const n=this.#g(e,r),i=this.lastIndexes;if("@"===t.at(0)){const n=t.slice(1),i=s.create(n);if((this.lastIndexes?.length??0)+1<i.level)throw new Error("array level not match");const h=this.lastIndexes?.slice(0,i.level-1)??[];return this.#P(e,{propName:i,indexes:h,values:a},r)}if(this.#N.has(t))return n(this.#N.get(t),a);const h=s.parse(t);return h.propName.level===h.indexes.length?(this.#N.set(t,h),n(h,a)):n({propName:h.propName,indexes:h.indexes.concat(i?.slice(h.indexes.length)??[])},a)}return Reflect.set(e,t,a,r)}}export{i as Handler,s as PropertyName,r as RE_CONTEXT_INDEX,a as Symbols};
