const e="*",t="dot-notation",r=Symbol.for(t+".direct_get"),s=Symbol.for(t+".direct_set");class a{name;pathNames=[];parentPathNames=[];parentPath;regexp;level=0;isPrimitive;privateName;constructor(t){this.name=t,this.pathNames=t.split("."),this.parentPathNames=this.pathNames.slice(0,-1),this.parentPath=this.parentPathNames.join("."),this.lastPathName=this.pathNames.at(-1),this.regexp=new RegExp("^"+t.replaceAll(".","\\.").replaceAll("*","([0-9a-zA-Z_]*)")+"$"),this.level=this.pathNames.filter((t=>t===e)).length,this.isPrimitive=1===this.pathNames.length,this.privateName=this.isPrimitive?`_${this.name}`:void 0}findNearestWildcard(){return a.findNearestWildcard(this)}static findNearestWildcard(t){return t.lastPathName===e?t:""!==t.parentPath?this.findNearestWildcard(a.create(t.parentPath)):void 0}static create(e){const t=this.propertyNameByName.get(e);if(t)return t;const r=new a(e);return this.propertyNameByName.set(e,r),r}static propertyNameByName=new Map}class i{#e=[];#t;#r;#s;constructor(e){if(null==e)throw new Error("definedProperties is null");this.#t=new Set(e),this.#r=e.map((e=>a.create(e))),this.#s=new Map}get lastIndexes(){return this.#e[this.#e.length-1]}get stackIndexes(){return this.#e}get setOfDefinedProperties(){return this.#t}get definedPropertyNames(){return this.#r}get matchByName(){return this.#s}#a(t,{propName:r},s){let i;if(Reflect.has(t,r.name,s))i=Reflect.get(t,r.name,s);else if(r.isPrimitive)i=Reflect.get(t,r.privateName,s);else{const n=this.#a(t,{propName:a.create(r.parentPath)},s),h=r.lastPathName===e?this.lastIndexes[r.level-1]:r.lastPathName;i=Reflect.get(n,h)}return i}#i(t,{propName:r,value:s},i){if(Reflect.has(t,r.name,i))Reflect.set(t,r.name,s,i);else if(r.isPrimitive)Reflect.set(t,r.privateName,s,i);else{const n=this.#a(t,{propName:a.create(r.parentPath)},i),h=r.lastPathName===e?this.lastIndexes[r.level-1]:r.lastPathName;Reflect.set(n,h,s)}return!0}#n(e,t){this.#e.push(e);try{return Reflect.apply(t,this,[])}finally{this.#e.pop()}}#h=(e,t)=>({propName:r,indexes:s})=>this.#n(s,(()=>this.#a(e,{propName:r},t)));#o=(e,t)=>({propName:r,indexes:s},a)=>this.#n(s,(()=>this.#i(e,{propName:r,value:a},t)));#p(e,{propName:t,indexes:r},s){const i=this.#h(e,s),n=t.findNearestWildcard();if(!n)throw new Error(`not found wildcard path of '${t.name}'`);const h=a.create(n.parentPath),o=[];for(let e in i({propName:h,indexes:r}))o.push(i({propName:t,indexes:r.concat(Number(e))}));return o}#m(e,{propName:t,indexes:r,values:s},i){const n=this.#h(e,i),h=this.#o(e,i),o=t.findNearestWildcard();if(!o)throw new Error(`not found wildcard path of '${t.name}'`);const p=a.create(o.parentPath),m=n({propName:p,indexes:r});if(o.name===t.name)h({propName:p,indexes:r},s);else{if(s.length!==m.length)throw new Error(`not match value count '${t.name}'`);for(let e in m)h({propName:t,indexes:r.concat(Number(e))},s[e])}return!0}get(e,t,i){const n=this.#h(e,i);let h;if(t===r)return(t,r)=>{if(this.#t.has(t))return this.#n(r,(()=>this.#a(e,{propName:a.create(t)},i)));throw new Error(`undefined property ${t}`)};if(t===s)return(t,r,s)=>{if(this.#t.has(t))return this.#n(r,(()=>this.#i(e,{propName:a.create(t),value:s},i)));throw new Error(`undefined property ${t}`)};if(h=/^\$([0-9]+)$/.exec(t))return this.lastIndexes?.[Number(h[1])-1]??void 0;if("@"===t.at(0)){const r=t.slice(1);if(!this.#t.has(r))throw new Error(`undefined property ${r}`);const s=a.create(r);if((this.lastIndexes?.length??0)+1<s.level)throw new Error("array level not match");const n=this.lastIndexes?.slice(0,s.level-1)??[];return this.#p(e,{propName:s,indexes:n},i)}if(this.#t.has(t))return this.#a(e,{propName:a.create(t)},i);if(this.#s.has(t))return n(this.#s.get(t));for(const e of this.#r){const r=e.regexp.exec(t);if(!r)continue;const s=r.slice(1);return this.#s.set(t,{propName:e,indexes:s}),n({propName:e,indexes:s})}throw new Error(`undefined property ${t}`)}set(e,t,r,s){const i=this.#o(e,s);if("@"===t.at(0)){const i=t.slice(1);if(!this.#t.has(i))throw new Error(`undefined property ${i}`);const n=a.create(i);if((this.lastIndexes?.length??0)+1<n.level)throw new Error("array level not match");const h=this.lastIndexes?.slice(0,n.level-1)??[];return this.#m(e,{propName:n,indexes:h,values:r},s)}if(this.#t.has(t))return this.#i(e,{propName:a.create(t),value:r},s);if(this.#s.has(t))return i(this.#s.get(t),r);for(const e of this.#r){const s=e.regexp.exec(t);if(!s)continue;const a=s.slice(1);return this.#s.set(t,{propName:e,indexes:a}),i({propName:e,indexes:a},r)}throw new Error(`undefined property ${t}`)}}export{i as Handler,a as PropertyName,r as SYM_DIRECT_GET,s as SYM_DIRECT_SET};
